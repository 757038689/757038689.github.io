<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="Chinese[中文]">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="秀起我的小肌肉">
<meta name="keywords" content="PHP,Mysql,swoole">
<meta property="og:type" content="website">
<meta property="og:title" content="梦逍遥">
<meta property="og:url" content="https://757038689.github.io/index.html">
<meta property="og:site_name" content="梦逍遥">
<meta property="og:description" content="秀起我的小肌肉">
<meta property="og:locale" content="Chinese[中文]">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="梦逍遥">
<meta name="twitter:description" content="秀起我的小肌肉">





  
  
  <link rel="canonical" href="https://757038689.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>梦逍遥</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="Chinese[中文]">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">梦逍遥</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">小北</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-首页 menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/24/k/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/24/k/" class="post-title-link" itemprop="url">PHP基础知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-24 22:49:21" itemprop="dateCreated datePublished" datetime="2019-04-24T22:49:21+08:00">2019-04-24</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/新起点/" itemprop="url" rel="index"><span itemprop="name">新起点</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>PHP中最基本的数据存储单元是变量和常量。
</code></pre><h4 id="1-认识变量"><a href="#1-认识变量" class="headerlink" title="1.认识变量:"></a>1.认识变量:</h4><pre><code>1.1 定义:以$开头，变量名一定不要以数字开头，中间不可以使用空格，不能使用点分开，由字母,下划线组成.
1.2 类型:整型，浮点型，字符串，布尔型，对象，数组，资源类型， null。
注意项：
布尔型为false的情况:
[1]布尔型false。
[2]整数值0（零）为假，-1和其他非零值（不论正负）一样，认为是true。
[3]浮点型值0.0。
[4]空白字符和字符串&apos;0&apos;。
[5]没有成员变量的数组。
[6]没有单元的对象(仅适用PHP4)。
[7]特殊类型NULL（包括尚未设定的变量）。

浮点型：最好不参与判断，两个浮点数是否相等。

字符串: 可以使用单引号，双引号，定界符定义。
注意点: 单引号不会解析变量，双引号和定界符都可以解析变量。从效率看单引号是最高的，因为它不用解析变量。

数组:是PHP一种重要的数据类型。

对象:是PHP一种复合数据类型，但它是一种更高级的数据类型。

资源类型:资源是一种特殊的变量，保存到外部资源的一个引用，资源是通过专门的函数来建立和使用的。比如链接数据库资源。

null:表示一个变量没有值，将变量直接赋值为null，声明变量尚未赋值，被unset()函数销毁的变量。

1.3 数据转换:
[1]自动转换，一般参与运算时会自动转换。
[2]强制转换, 通过转换函数intval() floatval(),strval()等。

1.4 变量类型的测试函数
比如:is_bool(), is_int(), is_long(), is_float(), is_double(),is_real(),is_string(),is_array(),is_object(),is_resource(),is_null()

常量:
define(&apos;名称&apos;,值)  名称一般用大写。
注意: 如果使用一个没有声明的常量，则常量名称会被解析为一个普通字符串，但会比直接使用字符串慢近8倍，所以在声明字符串时一定要加上单引号或双引号。
[1]常量前面没有美元符号($)
[2]常量只能用define()函数定义，而不能通过赋值语句。
[3]常量可以不用理会变量分范围的规则而在任何地方定义和访问。
[4]常量一旦定义就不能重新被定义或者取消定义，直到脚本运行结束自动释放。
[5]常量的值只能是标量Boolean，int, float, string。

魔术变量:
__FILE__     当前的文件名
__LINE__     当前的行数
__FUNCTION__ 当前的函数名称
__CLASS__    当前的类名
__METHOD__   当前对象的方法


运算符特别注意:@错误控制运算符，可能产生的任何错误都被忽略。

变量根据范围区分：局部变量和全局变量,【内：静态变量】。
局部变量一般在方法内部使用，不能在外部使用，而全局可以通过global声明，实现内外使用。
static关键字定义。它不会自动释放，在第一次初始化后，一直保存在内存中。
</code></pre><h4 id="2-PHP的流程控制结构"><a href="#2-PHP的流程控制结构" class="headerlink" title="2.PHP的流程控制结构"></a>2.PHP的流程控制结构</h4><pre><code>1.单一条件分支结构 if
2.双向条件分支结构 if..else..
3.多向条件分支结构 if..elseif..else..
4.巢状条件分支结构 switch ..case...break.. /if( if..else..)elseif()...else...

特殊流程语句:
break :可以结束当前for，foreach，while，do-while和switch的结构执行。
continue：只能使用在循环语句内部，功能是跳过该次循环，继续执行下次循环。
exit(),die()函数，直接退出当前脚本。
</code></pre><blockquote>
<p>   echo,print()是语言结构，print_r()是函数，从效率上看 echo &gt; print() &gt; print_r()<br>    printf()输出格式化的字符串。</p>
</blockquote>
<h4 id="3-PHP函数应用"><a href="#3-PHP函数应用" class="headerlink" title="3.PHP函数应用"></a>3.PHP函数应用</h4><pre><code>定义:一个被命名的，独立的代码段。
特点:被命名的，独立的，执行特定任务的，可以将一个返回值给调用它的程序。
优点：重用性，可维护性，开发效率，可靠性，复杂性。

特别注意回调函数:指调用函数时并不是传递一个标准的变量作为参数，而是将另一个函数作为参数传递到调用的函数中。
比如:
function demo(&apos;one&apos;){
    $fun($i);
}

function one($a){
    $a++;
}

可以使用PHP内置函数实现回调:call_user_func_array();
递归函数，就是在函数内部调用自己.

注意：
require()和include()不是函数，跟echo()都是语言结构。
require_once()和include_once()，如果该文件中的代码已经包含了，则不会再次包含。
</code></pre><h4 id="4-PHP的数组和数据结构"><a href="#4-PHP的数组和数据结构" class="headerlink" title="4.PHP的数组和数据结构"></a>4.PHP的数组和数据结构</h4><pre><code>分类:索引数组和关联数组。
遍历数组:for,foreach()，或者联合each(),list(),while()遍历数组
each()返回键/值对，指针并向后移动下一个元素位置，当没有返回false。
</code></pre><h4 id="5-PHP面向对象"><a href="#5-PHP面向对象" class="headerlink" title="5.PHP面向对象"></a>5.PHP面向对象</h4><pre><code>5.1 面向对象的单位就是对象。
5.2 内存分配:栈空间段，堆空间段，数据段，代码段
认识构造方法和析构方法:
__construct() 每次使用new关键字来实例化对象时都会自动调用构造方法，不能主动通过对象的引用调用构造方法，构造方法一般执行一些有效的初始化任务，比如赋予属性初始值。
__destruct() 对象被销毁前自动调用的方法，当对象不能被访问就会自动启动垃圾回收的程序，收回对象在堆栈中占用的内存空间。
</code></pre><blockquote>
<p>  注意点:栈内存：先进后出。</p>
</blockquote>
<ul>
<li><p>面向对象三大特性:封装性，继承性，多态性。<br>5.3 封装性:原则就是要求对象以外的部分不能随意存取对象内部数据(成员属性和成员方法)，从而有效地避免了外部错误对它的”交叉感染”，使软件错误能够局部化，大大减小差错和排错的难度。<br>1.对象中的成员属性一旦被pravite关键字封装成私有之后，就只能在对象内部的成员方法中使用，不能被对象外部直接赋值，也不能在对象外部直接获取成员属性。但可以通过关键字public</p>
<blockquote>
<p>   注意:可以通过<strong>set()和</strong>get()给私有属性设置值和获取私有属性。</p>
</blockquote>
</li>
<li><p>魔术方法:<br><strong>get(),</strong>set(),<strong>isset(),</strong>unset()</p>
<p>5.4 继承性：一个类只能直接从另一个类中继承数据，一个类可以有多个子类。关键字:extends<br>访问类型控制:<br>private,protected,public<br>private:只能在类中访问，子类和外部成员都没权访问.<br>protected:类中和子类都可以访问，外部成员不能访问.<br>public：类中，子类，外部成员都可以访问.</p>
<p>5.5 子类重载父类<br>1.父类方法不能重载，但是子类可以定义和父类同名的方法。<br>2.子类重载可以调用父类中被它覆盖的方法，调用格式:parent::方法名()。</p>
</li>
<li><p>常见关键字和魔术方法<br>final, static, const，instanceof 等关键字<br><strong>call(), </strong>toString(), <strong>autoload(), </strong>sleep(), __wakeup()</p>
<p>final关键字:</p>
<blockquote>
<p>   1.使用final标识的类，不能被继承。<br>2.在类中使用final标识的成员方法，在子类中不能被覆盖。</p>
</blockquote>
<p>static关键字:可以标识成员属性，也可以标识成员方法。<br>1.static标识的成员是属于类的，与对象实例和其他的类无关。<br>2.不能用$this来引用。<br>格式1: 类名::静态成员属性名, 类名::静态成员方法名()<br>格式2: self::静态成员属性，  self::静态成员方法()</p>
<p>const关键字:将类中的成员属性定义为常量。self访问,不能加$符号。</p>
<p>instanceof 关键字可以确定一个对象是类的实例，类的子类，还是实现了某个特定接口。</p>
<p>3.魔术方法<br><strong>toString()快速获取对象的字符串表示的最便捷的方式。
</strong>call() 调用对象中不存在的方法时就会自动调用该方法,使程序可以继续往下执行。<br>__autoload()自动加载函数</p>
<p>4.对象串行化:<br>serialize(), 反串行化 unserialize()函数</p>
<p>5.6 设计模式<br>1.单态模式:保证在面向对象编程设计中，一个类只能有一个实例对象存在。<br>使用场景:链接数据库，创建目录等。<br>2.工厂模式:<br>3.抽象工厂:</p>
<p>5.7 抽象类和接口<br>抽象类是一种特殊的类，接口也是一种特殊的抽象类。用abstract修饰.<br>抽象方法就是没有方法体的方法。<br>abstract function fun1();</p>
<p>继承接口关键字:implements</p>
<blockquote>
<p>   PHP是单继承的，一个类只能有一个父类，但是一个类可以实现多个接口。</p>
</blockquote>
<p>5.7 多态性:方法的重写。<br>重写要求子类的方法和父类的方法名称相同。</p>
</li>
</ul>
<h4 id="6-PHP的错误和异常处理"><a href="#6-PHP的错误和异常处理" class="headerlink" title="6 PHP的错误和异常处理"></a>6 PHP的错误和异常处理</h4><pre><code>1.错误类型:语法错误,运行时错误,逻辑错误。
2.常见错误报告级别:
    E_ERROR 致命错误
    E_WARNING 运行时警告(非致命的错误)
    E_PARSE 从语法中解析错误

如果要报告错误消息,可以通过php.ini文件设置display_errors为on，或者在php脚本上面调用ini_set()函数。
error_reporting(0)  完全关闭错误报告。
error_reporting(E_ALL)  报告每个错误。
</code></pre><h4 id="7-PHP的日期和时间"><a href="#7-PHP的日期和时间" class="headerlink" title="7 PHP的日期和时间"></a>7 PHP的日期和时间</h4><pre><code>7.1 mktime(int hour, int minute, int second, int month, int day, int year);该函数对于日期运算和验证非常有用，它可以自动校正越界的输入。
7.2 strtotime(), 返回时间戳。
常用时间函数:
time() 当前时间戳, gettimeofday()获取某一天的具体时间，getday()确定当前时间, date_sunrise()和date_sunset() 获取某地某天的日出时间和日落时间。
</code></pre><blockquote>
<p>   实例:date_sunset(time(), SUNFUNCS_RET_STRING, 38.4, -9, 90, 1);<br>    date(),日期格式化输出, microtime() 这个函数可以统计脚本执行时间。</p>
</blockquote>
<h4 id="8-文件处理系统"><a href="#8-文件处理系统" class="headerlink" title="8 文件处理系统"></a>8 文件处理系统</h4><pre><code>数据持久化方式:1.保存到文件，2.保存数据库表。
8.1 文件属性:
file_exists()检查文件或目录是否存在，返回true或者false。
filesize()   取得文件大小。
is_readble() 判断给定文件名是否可读。
is_writable() 判断给定文件是否可写。
is_executable() 判断给定文件是否可执行。
filectime() 获取文件的创建时间。
filemtime() 获取文件的修改时间。
stat() 获取文件的大部分属性值。

basename(), 返回路径中的文件名部分。string basename(string path [,string suffix]);
dirname(),  返回去掉文件名后的目录名。
pathinfo(), 返回一个关联数组，包含路径中的目录名，基本名，扩展名。
</code></pre><ul>
<li><p>遍历目录需要的函数:<br>opendir(), readdir(),closedir()和rewinddir()<br>opendir()用于打开指定目录，接受一个目录的路径及目录作为参数，函数返回值作为可供其他目录函数使用的目录句柄(资源类型)<br>readdir()用于读取指定目录，接受已经用opendir()打开的可操作的目录句柄作为参数，函数返回当前目录指针位置的一个文件名，并将目录指针向后移动一位，当指针位于目录的结尾时，没有文件返回则返回false。<br>closedir()关闭指定目录。</p>
<p>mkdir() 通过传入目录名，建立一个新目录。<br>rmdir() 只能删除一个空目录并且目录必须存在。<br>copy() 复制目录</p>
<p>fopen() 打开文件 fopen(string filename, string mode [, bool use_include_path [, resource zcontext]]);<br>fclose()关闭文件</p>
<p>//todo</p>
</li>
</ul>
<h4 id="9-mysql表设计"><a href="#9-mysql表设计" class="headerlink" title="9 mysql表设计"></a>9 mysql表设计</h4><pre><code>9.1 数据值的分类: 数值型， 字符型，日期型，和空值。
9.2 索引类型:主键索引，常规索引, 唯一索引，全文索引。
9.3 遵循三范式。
</code></pre><ul>
<li>联合索引:<br>比如 key(a, b, c) =&gt; a, a,b a,b,c 不能b,c 组合。<br>1.联合索引的使用在写where条件的顺序无关，mysql查询分析会进行优化而使用索引。但是减轻查询分析器的压力，最好和索引的从左到右的顺序一致。<br>2.使用等值查询，多列同时查询，索引会一直传递并生效。因此等值查询效率最好。<br>3.索引查找遵循最左侧原则。但是遇到范围查询列之后的列索引失效。<br>4.排序也能使用索引，合理使用索引排序，避免出现file sort。</li>
</ul>
<h4 id="10-SQL优化"><a href="#10-SQL优化" class="headerlink" title="10 SQL优化:"></a>10 SQL优化:</h4><pre><code>1.as 给字段取别名。
2.distinct 关键字取消重复的数据。
详细请复习19章.
</code></pre><h4 id="11-PHP访问Mysql"><a href="#11-PHP访问Mysql" class="headerlink" title="11 PHP访问Mysql"></a>11 PHP访问Mysql</h4><pre><code>11.1 方式:面向过程:mysql 面向对象:mysqli和 PDO。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/20/j/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/20/j/" class="post-title-link" itemprop="url">PHP基础知识整理一</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-20 17:03:12" itemprop="dateCreated datePublished" datetime="2019-04-20T17:03:12+08:00">2019-04-20</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/基础知识/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-了解PHP-fpm"><a href="#1-了解PHP-fpm" class="headerlink" title="1.了解PHP-fpm"></a>1.了解PHP-fpm</h4><pre><code>FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。

它主要功能:
1.支持平滑停止/启动的高级进程管理功能。
2.可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）。
3.stdout 和 stderr 日志记录。
4.在发生意外情况的时候能够重新启动并缓存被破坏的 opcode。
5.文件上传优化支持。
6.&quot;慢日志&quot; - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢。
7.动态／静态子进程产生。
8.基本 SAPI 运行状态信息（类似Apache的 mod_status）。
9.基于 php.ini 的配置文件。
</code></pre><h4 id="2-了解CGI-它是一种协议"><a href="#2-了解CGI-它是一种协议" class="headerlink" title="2.了解CGI[它是一种协议]"></a>2.了解CGI[它是一种协议]</h4><pre><code>CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。
CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。
</code></pre><blockquote>
<p>   PHP的解释器是php-cgi,只是个CGI的程序,本身只能解析请求，返回结果，不会管理进程，所以就出现了一些能够调度php-cgi进程的程序。    </p>
</blockquote>
<h4 id="3-了解FastCGI-是CGI的升级版"><a href="#3-了解FastCGI-是CGI的升级版" class="headerlink" title="3. 了解FastCGI[是CGI的升级版]"></a>3. 了解FastCGI[是CGI的升级版]</h4><pre><code>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次（这是CGI最为人诟病的fork-and-execute 模式）。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。
FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。
</code></pre><ul>
<li><p>FastCGI具有的特点语言无关性:<br>FastCGI在进程中的应用程序，独立于核心web服务器运行，提供了一个比API更安全的环境。APIs把应用程序的代码与核心的web服务器链接在一起，这意味着在一个错误的API的应用程序可能会损坏其他应用程序或核心服务器。 恶意的API的应用程序代码甚至可以窃取另一个应用程序或核心服务器的密钥。<br>FastCGI技术目前支持语言有：C/C++、Java、Perl、Tcl、Python、SmallTalk、Ruby等。相关模块在Apache, ISS, Lighttpd等流行的服务器上也是可用的。<br>FastCGI的不依赖于任何Web服务器的内部架构，因此即使服务器技术的变化, FastCGI依然稳定不变。</p>
</li>
<li><p>FastCGI的工作原理:<br>1.Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)<br>2.FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。<br>3.当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。<br>4.FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。    </p>
</li>
<li><p>FastCGI的不足：<br>因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。    </p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/17/i/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/17/i/" class="post-title-link" itemprop="url">开源框架CI，TP5，symfony的优缺点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-17 15:37:44" itemprop="dateCreated datePublished" datetime="2019-04-17T15:37:44+08:00">2019-04-17</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/框架/" itemprop="url" rel="index"><span itemprop="name">框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="CodeIgnite框架的优-缺点"><a href="#CodeIgnite框架的优-缺点" class="headerlink" title="CodeIgnite框架的优/缺点:"></a>CodeIgnite框架的优/缺点:</h4><ul>
<li>优点:</li>
</ul>
<ol>
<li>配置简单，全部配置都用PHP脚本进行配置,执行效率高，具有基本的路由功能，能够进行一定程度的路由，具有初步的layout功能，能够制作一定程度的界面外观。</li>
<li>快速简洁，代码不多，执行性能高，PHP框架简单，容易上手，学习成本低，文档详细，自带很多简单好用的library，框架适合小型应用。    </li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>把Model层简单的理解为数据库操作。</li>
<li>PHP框架略显简单，只能够满足小型应用，略微不太能够满足中型应用需要。</li>
</ol>
<h4 id="TP5框架"><a href="#TP5框架" class="headerlink" title="TP5框架"></a>TP5框架</h4><ul>
<li>优点:</li>
</ul>
<ol>
<li>ThinkPHP是一个轻量级的中型框架,是从Java的Struts结构移植过来的中文PHP开发框架。</li>
<li>易于上手，有丰富的中文文档；学习成本低，社区活跃度高。</li>
<li>框架的兼容性较强，PHP4和PHP5完全兼容、完全支持UTF8等。</li>
<li>适合用于中小项目的开发。</li>
<li>从3.22版本开始引入composer包管理工具。</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>目录结构混乱，相比其他框架目录结构要差一点。</li>
<li>对Ajax的支持不是很好。</li>
<li>上手容易，但是深入学习较难。</li>
</ol>
<h4 id="symfony框架的优缺点"><a href="#symfony框架的优缺点" class="headerlink" title="symfony框架的优缺点:"></a>symfony框架的优缺点:</h4><ul>
<li>优点:</li>
</ul>
<ol>
<li>它是面对大型的，复杂的项目框架，方便多人协助，方便代码复用。</li>
<li>完整实现MVC三层，封装了所有东西，包括 $_POST，$_GET 数据，异常处理，调试功能，数据检测；包含强大的缓存功能，自动加载Class（这个功能很爽），强大的i18n国家化支持；具有很强大的view层操作，能够零碎的包含单个多个文件；非常强大的配置功能，使用yml配置能够控制所有框架和程序运行行为，强大到让人无语；能够很随意的定义各种自己的class，并且symfony能够自动加载（auto load）这些class，能够在程序中随意调用；包含强大的多层级项目和应用管理：Project –&gt; Application –&gt; Module –&gt; Action，能够满足一个项目下多个应用的需要，并且每层可以定义自己的类库，配置文件，layout；非常强大的命令行操作功能，包括建立项目、建立应用、建立模块、刷新缓存等等。</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>效率不是很高，主要表现在解析模板和读取配置文件的过程，花费时间不少。</li>
<li><p>学习成本很高，并且国内没有成熟的社区和文档，连中文手册都没有，相应的要掌握所有功能，需要花费比较多的时间。</p>
<p>注意仅供参考！！！</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/16/e-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/16/e-1/" class="post-title-link" itemprop="url">PHP实现多台服务器的session共享</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-16 21:18:43" itemprop="dateCreated datePublished" datetime="2019-04-16T21:18:43+08:00">2019-04-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/session共享/" itemprop="url" rel="index"><span itemprop="name">session共享</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>本文的session共享主要场景是nginx服务下session共享
</code></pre><h4 id="1-不使用session，使用cookie"><a href="#1-不使用session，使用cookie" class="headerlink" title="1.不使用session，使用cookie"></a>1.不使用session，使用cookie</h4><pre><code>因为session是保存在服务器端，而cookie是保存在客户端。那么可以考虑将客服访问服务器产生的session保存到客户端cookie，以cookie作为一个中转站，当客户访问服务器A，产生了session，则将它保存到cookie当中，当客户的请求分到服务器B的时候，服务器B会判断是否存在这个session，如果没有，则检查客户端的cookie是否有这个session，如有则同步到服务器B。如果都没有，则说明session真的不存在。这样就实现了色饿死哦那的共享.
</code></pre><blockquote>
<p>   这个方法的好处是简单，方便，也不会加大mysql的负担，但是不好的地方就是如果客户禁掉cookie，则session无法正常同步，这样会给网站造成损失，还有就是cookie不够安全，虽然经过了加密，但是还是可以进行伪造的。</p>
</blockquote>
<h4 id="2-将session保存到数据表"><a href="#2-将session保存到数据表" class="headerlink" title="2.将session保存到数据表."></a>2.将session保存到数据表.</h4><pre><code>PHP配置将session保存到数据表，这个数据必须和其他数据库表放在一起。如果MySQL做了集群的话，那么每个MySQL节点都要有这个数据表，并且这个数据表的数据必须实时同步。
</code></pre><blockquote>
<pre><code>这种同步数据库实现session共享的，会加大数据库的负担，同时增加mysql的IO，而且数据库读写速度并不是很快，不利于session同步。
</code></pre></blockquote>
<h4 id="3-session存在memached或者redis中"><a href="#3-session存在memached或者redis中" class="headerlink" title="3.session存在memached或者redis中"></a>3.session存在memached或者redis中</h4><pre><code>memached可以做分布式，将php配置session保存到memache中，这样PHP会自动建立一个session集群，将session数据保存到memache中。
</code></pre><blockquote>
<p>   这种将session保存到memache中的同步方式，不会加大mysql的负担，并且安全性要比cookie大大提高，把session保存到内存中，读取速度非常快。但是memache把内存分成很多种规格的块，每块都有大小，这样就决定了，memache不能完全利用内存，会产生很多碎片，如果内存不足还会造成内存溢出。</p>
</blockquote>
<h4 id="4-nginx的ip-hash技术能够将某个ip请求定向到同一台后端这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip-hash是在upstream配置中定义的："><a href="#4-nginx的ip-hash技术能够将某个ip请求定向到同一台后端这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip-hash是在upstream配置中定义的：" class="headerlink" title="4.nginx的ip_hash技术能够将某个ip请求定向到同一台后端这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的："></a>4.nginx的ip_hash技术能够将某个ip请求定向到同一台后端这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的：</h4><pre><code>upstream nginx.example.com
{ 
    server 192.168.74.235:80; 
    server 192.168.74.236:80;
    ip_hash;
}
server
{
    listen 80;
    location /
    {
        proxy_pass
        http://nginx.example.com;
    }
}

但是如果是下面两种情况，这个方法是不能实现的.
1.nginx不是最前端服务器：ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。
2.nginx的后端还有其它方式的负载均衡。
</code></pre><h4 id="5-使用upstream-hash"><a href="#5-使用upstream-hash" class="headerlink" title="5.使用upstream_hash"></a>5.使用upstream_hash</h4><pre><code>为了解决ip_hash一些问题，可以使用upstream_hash第三方模块。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/14/g/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/g/" class="post-title-link" itemprop="url">PHP的数据结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-14 18:23:37" itemprop="dateCreated datePublished" datetime="2019-04-14T18:23:37+08:00">2019-04-14</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-双向链表"><a href="#1-双向链表" class="headerlink" title="1.双向链表"></a>1.双向链表</h4><pre><code>双链表 (DLL) 是一个链接到两个方向的节点列表。当底层结构是 DLL 时, 迭代器的操作、对两端的访问、节点的添加或删除都具有 O (1) 的开销。因此, 它为栈和队列提供了一个合适的实现。
</code></pre><h4 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h4><pre><code>堆是遵循堆属性的树状结构: 每个节点都大于或等于其子级, 使用对堆全局的已实现的比较方法进行比较。
</code></pre><h4 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h4><pre><code>数组是以连续方式存储数据的结构, 可通过索引进行访问。不要将它们与 php 数组混淆: php 数组实际上是按照有序的列表实现的。
</code></pre><h4 id="4-映射"><a href="#4-映射" class="headerlink" title="4.映射"></a>4.映射</h4><pre><code>映射是一个数据拥有键值对。PHP 数组可以被看作是从整数/字符串到值的映射。SPL 提供了从对象到数据的映射。此映射也可用作对象集。    
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/14/h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/h/" class="post-title-link" itemprop="url">MYSQL的事务处理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-14 16:04:00 / Geändert am: 16:10:20" itemprop="dateCreated datePublished" datetime="2019-04-14T16:04:00+08:00">2019-04-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/事务处理/" itemprop="url" rel="index"><span itemprop="name">事务处理</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="数据库事务：是指作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全的不执行。"><a href="#数据库事务：是指作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全的不执行。" class="headerlink" title="数据库事务：是指作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全的不执行。"></a>数据库事务：是指作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全的不执行。</h4><p>  它具有以下特性[ACID]:</p>
<ol>
<li>原子性:是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>
<li>一致性:是指事务必须使数据库从一个一致的状态一致变成另一个一致的状态，即事务执行前后的状态要保持一致。</li>
<li>隔离性:是指数据库被多个用户并发访问时，  比如同时操作一张表，数据库为每一个用户开启的事务，不能被其他事务所影响，多个并发事务之间隔离。</li>
<li>持久性:是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。</li>
</ol>
<h4 id="如果没有隔离，会发生的几种问题"><a href="#如果没有隔离，会发生的几种问题" class="headerlink" title="如果没有隔离，会发生的几种问题:"></a>如果没有隔离，会发生的几种问题:</h4><ol>
<li>脏读：一个事务处理过程中读取了另一个未提交事务中的数据。</li>
<li>不可重复读:对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询的隔离期间，另一个事务修改并提交数据。</li>
<li>幻读:一个事务中读取到了别的事务插入的数据，从而导致前后不一致。</li>
</ol>
<h4 id="mysql中的锁机制"><a href="#mysql中的锁机制" class="headerlink" title="mysql中的锁机制"></a>mysql中的锁机制</h4><ol>
<li><p>一次封锁<br>因为有大量的并发访问，为了预防死锁，一般应用中采用的是一次封锁的方案：就是在方法的开始阶段，已经预先知道需要用到那些数据，然后全部锁住，在方法执行之后，再全部解锁。<br>这种方案可以有效避免死锁发生。</p>
</li>
<li><p>两段锁:加锁阶段和解锁阶段<br>加锁:读数据前需要申请获取S锁（共享锁：其他事务可以继续加共享锁，但不能加排他锁）；写数据前需要申请获取X锁（排他锁：其他事务不能获取任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。<br>解锁:当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能进行加锁操作。</p>
</li>
</ol>
<h4 id="mysql的锁类型"><a href="#mysql的锁类型" class="headerlink" title="mysql的锁类型"></a>mysql的锁类型</h4><ol>
<li>表锁：对一整张表加锁，并发能力低下（即使有分读锁、写锁），一般在DDL处理时使用。</li>
<li>行锁：只锁住特定行的数据，并发能力强，MySQL一般都是用行锁来处理并发事务。</li>
<li>CAP锁（间隙锁）：是MySQL使用索引对行锁两边的区间进行加锁，避免其他事务在这两个区间insert的一种锁。</li>
<li>NEXT-KEY锁:NEXT-KEY锁是行锁和GAP锁的合并（MySQL使用它来避免幻读）。</li>
<li>MVCC是innodb的乐观锁，可以提高mysql的读取操作性能，并解决mysql重复读的问题。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/12/f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/12/f/" class="post-title-link" itemprop="url">HTTP常见状态码整理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-12 11:55:39" itemprop="dateCreated datePublished" datetime="2019-04-12T11:55:39+08:00">2019-04-12</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试知识点/" itemprop="url" rel="index"><span itemprop="name">面试知识点</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1开头-（信息提示）"><a href="#1开头-（信息提示）" class="headerlink" title="1开头 （信息提示）"></a>1开头 （信息提示）</h4><pre><code>100  Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。
101  Switching Protocols 服务器将遵从客户的请求转换到另外一种协议。
</code></pre><h4 id="2开头-（请求成功）"><a href="#2开头-（请求成功）" class="headerlink" title="2开头 （请求成功）"></a>2开头 （请求成功）</h4><pre><code>表示成功处理了请求的状态代码。
200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 
201   （已创建）  请求成功并且服务器创建了新的资源。 
202   （已接受）  服务器已接受请求，但尚未处理。 
203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 
204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 
205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206   （部分内容）  服务器成功处理了部分 GET 请求。
</code></pre><h4 id="3开头-（请求被重定向）"><a href="#3开头-（请求被重定向）" class="headerlink" title="3开头 （请求被重定向）"></a>3开头 （请求被重定向）</h4><pre><code>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
</code></pre><h4 id="4开头-（请求错误）"><a href="#4开头-（请求错误）" class="headerlink" title="4开头 （请求错误）"></a>4开头 （请求错误）</h4><pre><code>这些状态代码表示请求可能出错，妨碍了服务器的处理
400   （错误请求） 服务器不理解请求的语法。 
401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403   （禁止） 服务器拒绝请求。
404   （未找到） 服务器找不到请求的网页。
405   （方法禁用） 禁用请求中指定的方法。 
406   （不接受） 无法使用请求的内容特性响应请求的网页。 
407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408   （请求超时）  服务器等候请求时发生超时。 
409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 
411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 
412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 
413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 
415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 
416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 
417   （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。
</code></pre><h4 id="5开头（服务器错误）"><a href="#5开头（服务器错误）" class="headerlink" title="5开头（服务器错误）"></a>5开头（服务器错误）</h4><pre><code>表示服务器在尝试处理请求时发生内部错误, 注意这些错误可能是服务器本身的错误，而不是请求出错。
500   （服务器内部错误）  服务器遇到错误，无法完成请求。 
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/12/e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/12/e/" class="post-title-link" itemprop="url">关于http与https的区别</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-12 11:24:53 / Geändert am: 11:26:28" itemprop="dateCreated datePublished" datetime="2019-04-12T11:24:53+08:00">2019-04-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/传输协议/" itemprop="url" rel="index"><span itemprop="name">传输协议</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>见字释义:<br>HTTP:超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTPS:是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<blockquote>
<pre><code>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
</code></pre></blockquote>
</li>
<li><p>HTTP与HTTPS的区别:</p>
</li>
</ul>
<ol>
<li><p>安全性:<br>http的连接很简单，是无状态的,都是未加密状态的明文；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
</li>
<li><p>是否收费:<br>http 不收费，https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
</li>
<li><p>使用的端口不一样:<br>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。    </p>
</li>
</ol>
<ul>
<li><p>https的加密原理:<br>[1].    客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。<br>[2].    Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>[3].    客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。<br>[4].    客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>[5].    Web服务器利用自己的私钥解密出会话密钥。<br>[6].    Web服务器利用会话密钥加密与客户端之间的通信。</p>
</li>
<li><p>https的优点：</p>
</li>
</ul>
<ol>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ol>
<ul>
<li>https的缺点：</li>
</ul>
<ol>
<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li>
<li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响.</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/12/d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/12/d/" class="post-title-link" itemprop="url">PHP关于GET和POST的区别</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-12 11:02:43 / Geändert am: 11:03:29" itemprop="dateCreated datePublished" datetime="2019-04-12T11:02:43+08:00">2019-04-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PHP提交方式/" itemprop="url" rel="index"><span itemprop="name">PHP提交方式</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="PHP-常见的提交数据方式有两种为-get和post，它们的区别有以下几种"><a href="#PHP-常见的提交数据方式有两种为-get和post，它们的区别有以下几种" class="headerlink" title="PHP 常见的提交数据方式有两种为:get和post，它们的区别有以下几种:"></a>PHP 常见的提交数据方式有两种为:get和post，它们的区别有以下几种:</h4><ol>
<li><p>url可见性:<br>get是url可见，而post是可见的。</p>
</li>
<li><p>数据传输上:<br>get是通过url地址拼接的方式，而post则是通过body体表单传输</p>
</li>
<li><p>缓存性:<br>get是可以缓存的，而post是不可以缓存。</p>
</li>
<li><p>页面回退的反应:<br>页面回退上一页get是不受影响的，但是post的话则要重新输入到表单提交。</p>
</li>
<li><p>传输数据大小:<br>get是由于url地址长度的限制，但是传输的数据量要小于post，<br>post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大。</p>
<blockquote>
<p>   注意的是:http协议并未规定get和post的长度限制。    </p>
</blockquote>
</li>
<li><p>传输的数据类型:<br>get只能传输ASCll字符，而post则可以传输更多类型的数据（整型，字符串，数组等）</p>
</li>
<li><p>从功能性的应用场景:<br>get一般用于搜索排序和筛选之类的操作（淘宝，支付宝,几乎所有常见的电商平台的搜索查询都是get提交），目的是资源的获取，读取数据。<br>post则应用修改和写入数据。</p>
</li>
<li><p>传输效率上看，post比get要慢一些:<br>其根本原因在于post在提交数据前要把请求头发给服务器进行确认，然后才真正发送数据.<br>post请求的过程:<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回100 Continue响应<br>（5）浏览器发送数据<br>（6）服务器返回200 OK响应 </p>
<p>get的请求过程:<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回200 OK响应<br>从请求过程看，get花费的时间大概为post的2/3左右。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://757038689.github.io/2019/04/12/c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Yuan">
      <meta itemprop="description" content="秀起我的小肌肉">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梦逍遥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/12/c/" class="post-title-link" itemprop="url">PHP面试遇到的问题整理一</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于:</span>
              

              
                
              

              <time title="Erstellt: 2019-04-12 00:01:43" itemprop="dateCreated datePublished" datetime="2019-04-12T00:01:43+08:00">2019-04-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-27 21:54:53" itemprop="dateModified" datetime="2019-04-27T21:54:53+08:00">2019-04-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技能总结/" itemprop="url" rel="index"><span itemprop="name">技能总结</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于redis与memached的区别"><a href="#关于redis与memached的区别" class="headerlink" title="关于redis与memached的区别"></a>关于redis与memached的区别</h3><ul>
<li>简单的区别有以下几点:</li>
</ul>
<ol>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储.</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份.</li>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用.</li>
</ol>
<ul>
<li><p>本质区别:<br>  在Redis中，并不是所有的数据都一直存储在内存中。这是和memached相比一个最大的区别。redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以 保持超过其机器本身内存大小的数据。当然，机器本身的内存必须要能够保持所有的key，毕竟这些数据是不会进行swap操作的。同时由于Redis将内存 中的数据swap到磁盘中的时候，提供服务的主线程和进行swap操作的子线程会共享这部分内存，所以如果更新需要swap的数据，Redis将阻塞这个 操作，直到子线程完成swap操作后才可以进行修改。</p>
<p>  使用Redis特有内存模型前后的情况对比：<br>  VM off: 300k keys, 4096 bytes values: 1.3G used<br>  VM on:  300k keys, 4096 bytes values: 73M used<br>  VM off: 1 million keys, 256 bytes values: 430.12M used<br>  VM on:  1 million keys, 256 bytes values: 160.09M used<br>  VM on:  1 million keys, values as large as you want, still: 160.09M used</p>
<p>  当从Redis中读取数据的时候，如果读取的key对应的value不在内存中，那么Redis就需要从swap文件中加载相应数据，然后再返回给请求方。 这里就存在一个I/O线程池的问题。在默认的情况下，Redis会出现阻塞，即完成所有的swap文件加载后才会相应。这种策略在客户端的数量较小，进行 批量操作的时候比较合适。但是如果将Redis应用在一个大型的网站应用程序中，这显然是无法满足大并发的情况的。所以Redis运行我们设置I/O线程 池的大小，对需要从swap文件中加载相应数据的读取请求进行并发操作，减少阻塞的时间。</p>
<p>  所以如果希望在海量数据的环境中使用好Redis，我相信理解Redis的内存设计和阻塞的情况是不可缺少的。</p>
</li>
<li><p>补充知识点:</p>
</li>
</ul>
<ol>
<li><p>网络IO模型<br>Memcached是多线程，非阻塞IO复用的网络模型，分为监听主线程和worker子线程，监听线程监听网络连接，接受请求后，将连接描述字pipe 传递给worker线程，进行读写IO, 网络层使用libevent封装的事件库，多线程模型可以发挥多核作用，但是引入了cache coherency和锁的问题，比如，Memcached最常用的stats 命令，实际Memcached所有操作都要对这个全局变量加锁，进行计数等工作，带来了性能损耗。</p>
<p>Redis使用单线程的IO复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll、kqueue和select，对于单纯只有IO操作来说，单线程可以将速度优势发挥到最大，但是Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的。</p>
</li>
<li><p>内存管理方面<br>Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，Item根据大小选择合适的chunk存储，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费，并且在内存仍然有很大空间时，新的数据也可能会被剔除，原因可以参考Timyang的文章：<a href="http://timyang.NET/data/Memcached-lru-evictions/" target="_blank" rel="noopener">http://timyang.NET/data/Memcached-lru-evictions/</a><br>Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片，Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据(但会尝试剔除部分临时数据)，这点上Redis更适合作为存储而不是cache。</p>
</li>
<li><p>数据一致性问题<br>Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。 Redis没有提供cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断。</p>
</li>
<li><p>存储方式及其它方面<br>Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能。<br>Redis除key/value之外，还支持list,set,sorted set,hash等众多数据结构，提供了KEYS进行枚举操作，但不能在线上使用，如果需要枚举线上数据，Redis提供了工具可以直接扫描其dump文件，枚举出所有数据，Redis还同时提供了持久化和复制等功能</p>
</li>
<li><p>关于不同语言的客户端支持<br>在不同语言的客户端方面，Memcached和Redis都有丰富的第三方客户端可供选择，不过因为Memcached发展的时间更久一些，目前看在客户端支持方面，Memcached的很多客户端更加成熟稳定，而Redis由于其协议本身就比Memcached复杂，加上作者不断增加新的功能等，对应第三方客户端跟进速度可能会赶不上，有时可能需要自己在第三方客户端基础上做些修改才能更好的使用。根据以上比较不难看出，当我们不希望数据被踢出，或者需要除key/value之外的更多数据类型时，或者需要落地功能时，使用Redis比使用Memcached更合适。</p>
</li>
</ol>
<blockquote>
<p>   关于redis的持久化:<br>    方式一:RDB,Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。【默认开启的】<br>    方式二:AOF,采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。【默认关闭的】    </p>
</blockquote>
<ul>
<li>总结:</li>
</ul>
<ol>
<li>Redis使用最佳方式是全部数据in-memory。</li>
<li>Redis更多场景是作为Memcached的替代者来使用。</li>
<li>/value之外的更多数据类型支持时，使用Redis更合适。</li>
<li>当存储的数据不能被剔除时，使用Redis更合适。</li>
</ol>
<h4 id="关于json和jsonp的区别和使用"><a href="#关于json和jsonp的区别和使用" class="headerlink" title="关于json和jsonp的区别和使用:"></a>关于json和jsonp的区别和使用:</h4><pre><code>JSON是一种基于文本的数据交换方式（不支持跨域），而JSONP是一种非官方跨域数据交互协议。
json不可以跨域，但是js可以跨域，所以可以通过封装js方法传输json数据，然后dataType=&apos;jsonp&apos;即可。
JSON是&quot;暗号&quot;，而JSONP则是接头方式。一个是描述信息的格式，一个是信息传递双方约定的方法。

1.json的优点:
[1]基于纯文本，跨平台传递极其简单。
[2]Javascript原生支持，后台语言几乎全部支持。
[3]轻量级数据格式，占用字符数量极少，特别适合互联网传递。
[4]可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的。
[5]容易编写和解析，当然前提是你要知道数据结构。



参考文章链接:https://www.cnblogs.com/JimBo-Wang/p/6552652.html
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mr.Yuan</p>
              <div class="site-description motion-element" itemprop="description">秀起我的小肌肉</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">总数</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Yuan</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
